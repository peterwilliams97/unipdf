/*
 * This file is subject to the terms and conditions defined in
 * file 'LICENSE.md', which is part of this source code package.
 */

// Default writing implementation.  Basic output with version 1.3
// for compatibility.

package model

import (
	"bufio"
	"bytes"
	"crypto/md5"
	"encoding/binary"
	"errors"
	"flag"
	"fmt"
	"io"
	"math/rand"
	"sort"
	"strings"
	"time"

	"github.com/unidoc/unipdf/v3/common"
	"github.com/unidoc/unipdf/v3/common/license"
	"github.com/unidoc/unipdf/v3/core"
	"github.com/unidoc/unipdf/v3/core/security"
	"github.com/unidoc/unipdf/v3/core/security/crypt"
)

var (
	pdfAuthor       = ""
	pdfCreationDate time.Time
	pdfCreator      = ""
	pdfKeywords     = ""
	pdfModifiedDate time.Time
	pdfProducer     = ""
	pdfSubject      = ""
	pdfTitle        = ""
	pdfIsPDFA       = false
)

type crossReference struct {
	Type int
	// Type 1
	Offset     int64
	Generation int64 // and Type 0
	// Type 2
	ObjectNumber int // and Type 0
	Index        int
}

func getIsPDFA() bool {
	return pdfIsPDFA
}

// SetIsPDFA makes PdfWriter output PDF/A-1B if `isPDFA` is true.
// Only set this if you know the PDF you are creating is PDF/A-1B compliant.
func SetIsPDFA(isPDFA bool) {
	pdfIsPDFA = isPDFA
}

func getPdfAuthor() string {
	return pdfAuthor
}

// SetPdfAuthor sets the Author attribute of the output PDF.
func SetPdfAuthor(author string) {
	pdfAuthor = author
}

func getPdfCreationDate() time.Time {
	return pdfCreationDate
}

// SetPdfCreationDate sets the CreationDate attribute of the output PDF.
func SetPdfCreationDate(creationDate time.Time) {
	pdfCreationDate = creationDate
}

func getPdfCreator() string {
	if len(pdfCreator) > 0 {
		return pdfCreator
	}

	// Return default.
	return "UniDoc - http://unidoc.io"
}

// SetPdfCreator sets the Creator attribute of the output PDF.
func SetPdfCreator(creator string) {
	pdfCreator = creator
}

func getPdfKeywords() string {
	return pdfKeywords
}

// SetPdfKeywords sets the Keywords attribute of the output PDF.
func SetPdfKeywords(keywords string) {
	pdfKeywords = keywords
}

func getPdfModifiedDate() time.Time {
	return pdfModifiedDate
}

// SetPdfModifiedDate sets the ModDate attribute of the output PDF.
func SetPdfModifiedDate(modifiedDate time.Time) {
	pdfModifiedDate = modifiedDate
}

func getPdfProducer() string {
	licenseKey := license.GetLicenseKey()
	if len(pdfProducer) > 0 && (licenseKey.IsLicensed() || flag.Lookup("test.v") != nil) {
		return pdfProducer
	}

	// Return default.
	return fmt.Sprintf("UniDoc v%s (%s) - http://unidoc.io", getUniDocVersion(), licenseKey.TypeToString())
}

// SetPdfProducer sets the Producer attribute of the output PDF.
func SetPdfProducer(producer string) {
	pdfProducer = producer
}

func getPdfSubject() string {
	return pdfSubject
}

// SetPdfSubject sets the Subject attribute of the output PDF.
func SetPdfSubject(subject string) {
	pdfSubject = subject
}

func getPdfTitle() string {
	return pdfTitle
}

// SetPdfTitle sets the Title attribute of the output PDF.
func SetPdfTitle(title string) {
	pdfTitle = title
}

// PdfWriter handles outputing PDF content.
type PdfWriter struct {
	root        *core.PdfIndirectObject
	pages       *core.PdfIndirectObject
	pagesMap    map[core.PdfObject]struct{} // Pages lookup table.
	objects     []core.PdfObject            // Objects to write.
	objectsMap  map[core.PdfObject]struct{} // Quick lookup table.
	outlines    []*core.PdfIndirectObject
	outlineTree *PdfOutlineTreeNode
	catalog     *core.PdfObjectDictionary
	fields      []core.PdfObject
	infoObj     *core.PdfIndirectObject

	// `writer` is the buffered writer for writing, `writePos` tracks the current writing
	// position, needed to generate cross-reference tables, `werr` is the first error
	// encountered during writing. All writes after the first error become no-ops.
	writer   *bufio.Writer
	writePos int64 // Represents the current position within output file.
	werr     error

	// Encryption
	crypter     *core.PdfCrypt
	encryptDict *core.PdfObjectDictionary
	encryptObj  *core.PdfIndirectObject
	ids         *core.PdfObjectArray

	// PDF version
	majorVersion int
	minorVersion int

	// Force whether or not to use cross reference streams.
	// Otherwise is used/not used depending on the PDF version (1.5 and above).
	useCrossReferenceStream *bool

	// Objects to be followed up on prior to writing.
	// These are objects that are added and reference objects that are not included
	// for writing.
	// The map stores the object and the dictionary it is contained in.
	// Only way so we can access the dictionary entry later.
	pendingObjects map[core.PdfObject][]*core.PdfObjectDictionary

	// Forms.
	acroForm *PdfAcroForm

	optimizer              Optimizer
	crossReferenceMap      map[int]crossReference
	writeOffset            int64 // used by PdfAppender
	ObjNumOffset           int
	appendMode             bool
	appendToXrefs          core.XrefTable
	appendXrefPrevOffset   int64
	appendPrevRevisionSize int64
	// Map of object to object number for replacements.
	appendReplaceMap map[core.PdfObject]int64

	// Cache of objects traversed while resolving references.
	traversed map[core.PdfObject]struct{}
}

// NewPdfWriter initializes a new PdfWriter.
func NewPdfWriter() PdfWriter {
	w := PdfWriter{}

	w.objectsMap = map[core.PdfObject]struct{}{}
	w.objects = []core.PdfObject{}
	w.pendingObjects = map[core.PdfObject][]*core.PdfObjectDictionary{}
	w.traversed = map[core.PdfObject]struct{}{}

	// PDF Version. Can be changed if using more advanced features in PDF.
	// By default it is set to 1.3.
	w.majorVersion = 1
	w.minorVersion = 3

	// Creation info.
	infoDict := core.MakeDict()
	metadata := []struct {
		key   core.PdfObjectName
		value string
	}{
		{"Producer", getPdfProducer()},
		{"Creator", getPdfCreator()},
		{"Author", getPdfAuthor()},
		{"Subject", getPdfSubject()},
		{"Title", getPdfTitle()},
		{"Keywords", getPdfKeywords()},
	}
	for _, tuple := range metadata {
		if tuple.value != "" {
			infoDict.Set(tuple.key, core.MakeString(tuple.value))
		}
	}

	// Set creation and modified dates.
	if creationDate := getPdfCreationDate(); !creationDate.IsZero() {
		if cd, err := NewPdfDateFromTime(creationDate); err == nil {
			infoDict.Set("CreationDate", cd.ToPdfObject())
		}
	}
	if modifiedDate := getPdfModifiedDate(); !modifiedDate.IsZero() {
		if md, err := NewPdfDateFromTime(modifiedDate); err == nil {
			infoDict.Set("ModDate", md.ToPdfObject())
		}
	}

	infoObj := core.PdfIndirectObject{}
	infoObj.PdfObject = infoDict
	w.infoObj = &infoObj
	w.addObject(&infoObj)

	// Root catalog.
	catalog := core.PdfIndirectObject{}
	catalogDict := core.MakeDict()
	catalogDict.Set("Type", core.MakeName("Catalog"))
	catalog.PdfObject = catalogDict

	w.root = &catalog
	w.addObject(w.root)

	// Pages.
	pages := core.PdfIndirectObject{}
	pagedict := core.MakeDict()
	pagedict.Set("Type", core.MakeName("Pages"))
	kids := core.PdfObjectArray{}
	pagedict.Set("Kids", &kids)
	pagedict.Set("Count", core.MakeInteger(0))
	pages.PdfObject = pagedict

	w.pages = &pages
	w.pagesMap = map[core.PdfObject]struct{}{}
	w.addObject(w.pages)

	catalogDict.Set("Pages", &pages)

	if getIsPDFA() {
		metaData, err := documentMetadataStream()
		if err != nil {
			common.Log.Error("Could not create Metadata. err=%v", err)
		} else {
			w.addObject(metaData)
			catalogDict.Set("Metadata", metaData)
		}

		iccProfile, outputIntent, err := outputIntentStream()
		if err != nil {
			common.Log.Error("Could not create iccProfile. err=%v", err)
		} else {
			outputIntents := core.PdfIndirectObject{PdfObject: core.MakeArray(outputIntent)}
			w.addObject(&outputIntents)
			w.addObject(iccProfile)
			catalogDict.Set("OutputIntents", &outputIntents)
			common.Log.Info("catalogDict=%s", catalogDict.Keys())
		}
	}

	w.catalog = catalogDict

	common.Log.Trace("Catalog %s", catalog)

	return w
}

// copyObject creates deep copy of the Pdf object and
// fills objectToObjectCopyMap to replace the old object to the copy of object if needed.
// Parameter objectToObjectCopyMap is needed to replace object references to its copies.
// Because many objects can contain references to another objects like pages to images.
// If a skip map is provided and the writer is not set to append mode, the
// children objects of pages which are not present in the catalog are added to
// the map and the page dictionaries are replaced with null objects.
func (w *PdfWriter) copyObject(obj core.PdfObject,
	objectToObjectCopyMap map[core.PdfObject]core.PdfObject,
	skipMap map[core.PdfObject]struct{}, skip bool) core.PdfObject {
	if newObj, ok := objectToObjectCopyMap[obj]; ok {
		return newObj
	}

	newObj := obj
	skipUnusedPages := !w.appendMode && skipMap != nil
	switch t := obj.(type) {
	case *core.PdfObjectArray:
		arrObj := core.MakeArray()
		newObj = arrObj
		objectToObjectCopyMap[obj] = newObj
		for _, val := range t.Elements() {
			arrObj.Append(w.copyObject(val, objectToObjectCopyMap, skipMap, skip))
		}
	case *core.PdfObjectStreams:
		streamsObj := &core.PdfObjectStreams{PdfObjectReference: t.PdfObjectReference}
		newObj = streamsObj
		objectToObjectCopyMap[obj] = newObj
		for _, val := range t.Elements() {
			streamsObj.Append(w.copyObject(val, objectToObjectCopyMap, skipMap, skip))
		}
	case *core.PdfObjectStream:
		streamObj := &core.PdfObjectStream{
			Stream:             t.Stream,
			PdfObjectReference: t.PdfObjectReference,
		}
		newObj = streamObj
		objectToObjectCopyMap[obj] = newObj
		streamObj.PdfObjectDictionary = w.copyObject(t.PdfObjectDictionary, objectToObjectCopyMap, skipMap, skip).(*core.PdfObjectDictionary)
	case *core.PdfObjectDictionary:
		// Check if the object is a page dictionary and search it in the
		// writer pages. If not found, replace it with a null object and add
		// the chain of children objects to the skip map.
		var unused bool
		if skipUnusedPages && !skip {
			if dictType, _ := core.GetNameVal(t.Get("Type")); dictType == "Page" {
				_, ok := w.pagesMap[t]
				skip = !ok
				unused = skip
			}
		}

		dictObj := core.MakeDict()
		newObj = dictObj
		objectToObjectCopyMap[obj] = newObj
		for _, key := range t.Keys() {
			dictObj.Set(key, w.copyObject(t.Get(key), objectToObjectCopyMap, skipMap, skip))
		}

		// If an unused page dictionary is found, replace it with a null object.
		if unused {
			newObj = core.MakeNull()
			skip = false
		}
	case *core.PdfIndirectObject:
		indObj := &core.PdfIndirectObject{
			PdfObjectReference: t.PdfObjectReference,
		}
		newObj = indObj
		objectToObjectCopyMap[obj] = newObj
		indObj.PdfObject = w.copyObject(t.PdfObject, objectToObjectCopyMap, skipMap, skip)
	case *core.PdfObjectString:
		strObj := *t
		newObj = &strObj
		objectToObjectCopyMap[obj] = newObj
	case *core.PdfObjectName:
		nameObj := core.PdfObjectName(*t)
		newObj = &nameObj
		objectToObjectCopyMap[obj] = newObj
	case *core.PdfObjectNull:
		newObj = core.MakeNull()
		objectToObjectCopyMap[obj] = newObj
	case *core.PdfObjectInteger:
		intObj := core.PdfObjectInteger(*t)
		newObj = &intObj
		objectToObjectCopyMap[obj] = newObj
	case *core.PdfObjectReference:
		refObj := core.PdfObjectReference(*t)
		newObj = &refObj
		objectToObjectCopyMap[obj] = newObj
	case *core.PdfObjectFloat:
		floatObj := core.PdfObjectFloat(*t)
		newObj = &floatObj
		objectToObjectCopyMap[obj] = newObj
	case *core.PdfObjectBool:
		boolObj := core.PdfObjectBool(*t)
		newObj = &boolObj
		objectToObjectCopyMap[obj] = newObj
	case *pdfSignDictionary:
		sigObj := &pdfSignDictionary{
			PdfObjectDictionary: core.MakeDict(),
			handler:             t.handler,
			signature:           t.signature,
		}
		newObj = sigObj
		objectToObjectCopyMap[obj] = newObj
		for _, key := range t.Keys() {
			sigObj.Set(key, w.copyObject(t.Get(key), objectToObjectCopyMap, skipMap, skip))
		}
	default:
		common.Log.Info("TODO(a5i): implement copyObject for %+v", obj)
	}

	if skipUnusedPages && skip {
		skipMap[obj] = struct{}{}
	}

	return newObj
}

// copyObjects makes objects copy and set as working.
func (w *PdfWriter) copyObjects() {
	objectToObjectCopyMap := make(map[core.PdfObject]core.PdfObject)
	objects := make([]core.PdfObject, 0, len(w.objects))
	objectsMap := make(map[core.PdfObject]struct{}, len(w.objects))
	skipMap := make(map[core.PdfObject]struct{})
	for _, obj := range w.objects {
		newObject := w.copyObject(obj, objectToObjectCopyMap, skipMap, false)
		if _, ok := skipMap[obj]; ok {
			continue
		}
		objects = append(objects, newObject)
		objectsMap[newObject] = struct{}{}
	}

	w.objects = objects
	w.objectsMap = objectsMap
	w.infoObj = w.copyObject(w.infoObj, objectToObjectCopyMap, nil, false).(*core.PdfIndirectObject)
	w.root = w.copyObject(w.root, objectToObjectCopyMap, nil, false).(*core.PdfIndirectObject)
	if w.encryptObj != nil {
		w.encryptObj = w.copyObject(w.encryptObj, objectToObjectCopyMap, nil, false).(*core.PdfIndirectObject)
	}

	// Update replace map.
	if w.appendMode {
		appendReplaceMap := make(map[core.PdfObject]int64)
		for obj, replaceNum := range w.appendReplaceMap {
			if objCopy, has := objectToObjectCopyMap[obj]; has {
				appendReplaceMap[objCopy] = replaceNum
			} else {
				common.Log.Debug("ERROR: append mode - object copy not in map")
			}
		}
		w.appendReplaceMap = appendReplaceMap
	}
}

// SetVersion sets the PDF version of the output file.
func (w *PdfWriter) SetVersion(majorVersion, minorVersion int) {
	w.majorVersion = majorVersion
	w.minorVersion = minorVersion
}

// SetOCProperties sets the optional content properties.
func (w *PdfWriter) SetOCProperties(ocProperties core.PdfObject) error {
	dict := w.catalog

	if ocProperties != nil {
		common.Log.Trace("Setting OC Properties...")
		dict.Set("OCProperties", ocProperties)
		// Any risk of infinite loops?
		return w.addObjects(ocProperties)
	}

	return nil
}

// SetNamedDestinations sets the Names entry in the PDF catalog.
// See section 12.3.2.3 "Named Destinations" (p. 367 PDF32000_2008).
func (w *PdfWriter) SetNamedDestinations(names core.PdfObject) error {
	if names == nil {
		return nil
	}

	common.Log.Trace("Setting catalog Names...")
	w.catalog.Set("Names", names)
	return w.addObjects(names)
}

// SetPageLabels sets the PageLabels entry in the PDF catalog.
// See section 12.4.2 "Page Labels" (p. 382 PDF32000_2008).
func (w *PdfWriter) SetPageLabels(pageLabels core.PdfObject) error {
	if pageLabels == nil {
		return nil
	}

	common.Log.Trace("Setting catalog PageLabels...")
	w.catalog.Set("PageLabels", pageLabels)
	return w.addObjects(pageLabels)
}

// SetOptimizer sets the optimizer to optimize PDF before writing.
func (w *PdfWriter) SetOptimizer(optimizer Optimizer) {
	w.optimizer = optimizer
}

// GetOptimizer returns current PDF optimizer.
func (w *PdfWriter) GetOptimizer() Optimizer {
	return w.optimizer
}

// hasObject returns true if `obj` has already been added.
func (w *PdfWriter) hasObject(obj core.PdfObject) bool {
	_, found := w.objectsMap[obj]
	return found
}

// addObject adds `obj` to the object list and returns true if the obj was not already added.
// Returns false if `obj` is already in the object list.
func (w *PdfWriter) addObject(obj core.PdfObject) bool {
	hasObj := w.hasObject(obj)
	if !hasObj {
		err := core.ResolveReferencesDeep(obj, w.traversed)
		if err != nil {
			common.Log.Debug("ERROR: %v - skipping", err)
		}

		w.objects = append(w.objects, obj)
		w.objectsMap[obj] = struct{}{}
		return true
	}

	return false
}

func (w *PdfWriter) addObjects(obj core.PdfObject) error {
	common.Log.Trace("Adding objects!")

	if io, isIndirectObj := obj.(*core.PdfIndirectObject); isIndirectObj {
		common.Log.Trace("Indirect")
		common.Log.Trace("- %s (%p)", obj, io)
		common.Log.Trace("- %s", io.PdfObject)
		if w.addObject(io) {
			err := w.addObjects(io.PdfObject)
			if err != nil {
				return err
			}
		}
		return nil
	}

	if so, isStreamObj := obj.(*core.PdfObjectStream); isStreamObj {
		common.Log.Trace("Stream")
		common.Log.Trace("- %s %p", obj, obj)
		if w.addObject(so) {
			err := w.addObjects(so.PdfObjectDictionary)
			if err != nil {
				return err
			}
		}
		return nil
	}

	if dict, isDict := obj.(*core.PdfObjectDictionary); isDict {
		common.Log.Trace("Dict")
		common.Log.Trace("- %s", obj)
		for _, k := range dict.Keys() {
			v := core.ResolveReference(dict.Get(k))
			if k != "Parent" {
				err := w.addObjects(v)
				if err != nil {
					return err
				}
			} else {
				if _, parentIsNull := dict.Get("Parent").(*core.PdfObjectNull); parentIsNull {
					// Parent is null.  We can ignore it.
					continue
				}

				if hasObj := w.hasObject(v); !hasObj {
					common.Log.Debug("Parent obj not added yet!! %T %p %v", v, v, v)
					w.pendingObjects[v] = append(w.pendingObjects[v], dict)
					// Although it is missing at this point, it could be added later...
				}
				// How to handle the parent? Make sure it is present?
				if parentObj, parentIsRef := dict.Get("Parent").(*core.PdfObjectReference); parentIsRef {
					// Parent is a reference.  Means we can drop it?
					// Could refer to somewhere outside of the scope of the output doc.
					// Should be done by the reader already.
					// -> ERROR.
					common.Log.Debug("ERROR: Parent is a reference object - Cannot be in writer (needs to be resolved)")
					return fmt.Errorf("parent is a reference object - Cannot be in writer (needs to be resolved) - %s", parentObj)
				}
			}
		}
		return nil
	}

	if arr, isArray := obj.(*core.PdfObjectArray); isArray {
		common.Log.Trace("Array")
		common.Log.Trace("- %s", obj)
		if arr == nil {
			return errors.New("array is nil")
		}
		for _, v := range arr.Elements() {
			err := w.addObjects(core.ResolveReference(v))
			if err != nil {
				return err
			}
		}
		return nil
	}

	if _, isReference := obj.(*core.PdfObjectReference); isReference {
		// Should never be a reference, should already be resolved.
		common.Log.Debug("ERROR: Cannot be a reference - got %#v!", obj)
		return errors.New("reference not allowed")
	}

	return nil
}

// AddPage adds a page to the PDF file. The new page should be an indirect object.
func (w *PdfWriter) AddPage(page *PdfPage) error {
	procPage(page)
	obj := page.ToPdfObject()

	common.Log.Trace("==========")
	common.Log.Trace("Appending to page list %T", obj)

	pageObj, ok := core.GetIndirect(obj)
	if !ok {
		return errors.New("page should be an indirect object")
	}
	common.Log.Trace("%s", pageObj)
	common.Log.Trace("%s", pageObj.PdfObject)

	pDict, ok := core.GetDict(pageObj.PdfObject)
	if !ok {
		return errors.New("page object should be a dictionary")
	}

	otype, ok := core.GetName(pDict.Get("Type"))
	if !ok {
		return fmt.Errorf("page should have a Type key with a value of type name (%T)", pDict.Get("Type"))

	}
	if otype.String() != "Page" {
		return errors.New("field Type != Page (Required)")
	}

	// Copy inherited fields if missing.
	inheritedFields := []core.PdfObjectName{"Resources", "MediaBox", "CropBox", "Rotate"}
	parent, hasParent := core.GetIndirect(pDict.Get("Parent"))
	common.Log.Trace("Page Parent: %T (%v)", pDict.Get("Parent"), hasParent)
	for hasParent {
		common.Log.Trace("Page Parent: %T", parent)
		parentDict, ok := core.GetDict(parent.PdfObject)
		if !ok {
			return errors.New("invalid Parent object")
		}
		for _, field := range inheritedFields {
			common.Log.Trace("Field %s", field)
			if pDict.Get(field) != nil {
				common.Log.Trace("- page has already")
				continue
			}

			if obj := parentDict.Get(field); obj != nil {
				// Parent has the field.  Inherit, pass to the new page.
				common.Log.Trace("Inheriting field %s", field)
				pDict.Set(field, obj)
			}
		}
		parent, hasParent = core.GetIndirect(parentDict.Get("Parent"))
		common.Log.Trace("Next parent: %T", parentDict.Get("Parent"))
	}

	common.Log.Trace("Traversal done")

	// Update the dictionary.
	// Reuses the input object, updating the fields.
	pDict.Set("Parent", w.pages)
	pageObj.PdfObject = pDict

	// Add to Pages.
	pagesDict, ok := core.GetDict(w.pages.PdfObject)
	if !ok {
		return errors.New("invalid Pages obj (not a dict)")
	}
	kids, ok := core.GetArray(pagesDict.Get("Kids"))
	if !ok {
		return errors.New("invalid Pages Kids obj (not an array)")
	}
	kids.Append(pageObj)
	w.pagesMap[pDict] = struct{}{}

	pageCount, ok := core.GetInt(pagesDict.Get("Count"))
	if !ok {
		return errors.New("invalid Pages Count object (not an integer)")
	}
	// Update the count.
	*pageCount = *pageCount + 1

	w.addObject(pageObj)

	// Traverse the page and record all object references.
	err := w.addObjects(pDict)
	if err != nil {
		return err
	}

	return nil
}

func procPage(p *PdfPage) {
	lk := license.GetLicenseKey()
	if lk != nil && lk.IsLicensed() {
		return
	}

	// Add font, if needed.
	fontName := core.PdfObjectName("UF1")
	if !p.Resources.HasFontByName(fontName) {
		p.Resources.SetFontByName(fontName, DefaultFont().ToPdfObject())
	}

	var ops []string
	ops = append(ops, "q")
	ops = append(ops, "BT")
	ops = append(ops, fmt.Sprintf("/%s 14 Tf", fontName.String()))
	ops = append(ops, "1 0 0 rg")
	ops = append(ops, "10 10 Td")
	s := "Unlicensed UniDoc - Get a license on https://unidoc.io"
	ops = append(ops, fmt.Sprintf("(%s) Tj", s))
	ops = append(ops, "ET")
	ops = append(ops, "Q")
	contentstr := strings.Join(ops, "\n")

	p.AddContentStreamByString(contentstr)

	// Update page object.
	p.ToPdfObject()
}

// AddOutlineTree adds outlines to a PDF file.
func (w *PdfWriter) AddOutlineTree(outlineTree *PdfOutlineTreeNode) {
	w.outlineTree = outlineTree
}

// Look for a specific key.  Returns a list of entries.
// What if something appears on many pages?
func (w *PdfWriter) seekByName(obj core.PdfObject, followKeys []string, key string) ([]core.PdfObject, error) {
	common.Log.Trace("Seek by name.. %T", obj)
	var list []core.PdfObject

	if io, isIndirectObj := obj.(*core.PdfIndirectObject); isIndirectObj {
		return w.seekByName(io.PdfObject, followKeys, key)
	}

	if so, isStreamObj := obj.(*core.PdfObjectStream); isStreamObj {
		return w.seekByName(so.PdfObjectDictionary, followKeys, key)
	}

	if dict, isDict := obj.(*core.PdfObjectDictionary); isDict {
		common.Log.Trace("Dict")
		for _, k := range dict.Keys() {
			v := dict.Get(k)
			if string(k) == key {
				list = append(list, v)
			}
			for _, followKey := range followKeys {
				if string(k) == followKey {
					common.Log.Trace("Follow key %s", followKey)
					items, err := w.seekByName(v, followKeys, key)
					if err != nil {
						return list, err
					}
					for _, item := range items {
						list = append(list, item)
					}
					break
				}
			}
		}
		return list, nil
	}

	return list, nil
}

// SetForms sets the Acroform for a PDF file.
func (w *PdfWriter) SetForms(form *PdfAcroForm) error {
	w.acroForm = form
	return nil
}

// writeObject writes out an indirect / stream object.
func (w *PdfWriter) writeObject(num int, obj core.PdfObject) {
	common.Log.Trace("Write obj #%d\n", num)

	if pobj, isIndirect := obj.(*core.PdfIndirectObject); isIndirect {
		w.crossReferenceMap[num] = crossReference{Type: 1, Offset: w.writePos, Generation: pobj.GenerationNumber}
		outStr := fmt.Sprintf("%d 0 obj\n", num)
		if sDict, ok := pobj.PdfObject.(*pdfSignDictionary); ok {
			sDict.fileOffset = w.writePos + int64(len(outStr))
		}
		if pobj.PdfObject == nil {
			common.Log.Debug("Error: indirect object's PdfObject should never be nil - setting to PdfObjectNull")
			pobj.PdfObject = core.MakeNull()
		}
		outStr += pobj.PdfObject.WriteString()
		outStr += "\nendobj\n"
		w.writeString(outStr)
		return
	}

	// TODO: Add a default encoder if Filter not specified?
	// Still need to make sure is encrypted.
	if pobj, isStream := obj.(*core.PdfObjectStream); isStream {
		w.crossReferenceMap[num] = crossReference{Type: 1, Offset: w.writePos, Generation: pobj.GenerationNumber}
		outStr := fmt.Sprintf("%d 0 obj\n", num)
		outStr += pobj.PdfObjectDictionary.WriteString()
		outStr += "\nstream\n"
		w.writeString(outStr)
		w.writeBytes(pobj.Stream)
		w.writeString("\nendstream\nendobj\n")
		return
	}

	if ostreams, isObjStreams := obj.(*core.PdfObjectStreams); isObjStreams {
		w.crossReferenceMap[num] = crossReference{Type: 1, Offset: w.writePos, Generation: ostreams.GenerationNumber}
		outStr := fmt.Sprintf("%d 0 obj\n", num)
		var offsets []string
		var objData string
		var offset int64

		for index, obj := range ostreams.Elements() {
			io, isIndirect := obj.(*core.PdfIndirectObject)
			if !isIndirect {
				common.Log.Debug("ERROR: Object streams N %d contains non indirect pdf object %v", num, obj)
				continue
			}
			data := io.PdfObject.WriteString() + " "
			objData = objData + data
			offsets = append(offsets, fmt.Sprintf("%d %d", io.ObjectNumber, offset))
			w.crossReferenceMap[int(io.ObjectNumber)] = crossReference{Type: 2, ObjectNumber: num, Index: index}
			offset = offset + int64(len([]byte(data)))
		}
		offsetsStr := strings.Join(offsets, " ") + " "
		encoder := core.NewFlateEncoder()
		// For debugging:
		//encoder := core.NewRawEncoder()
		dict := encoder.MakeStreamDict()
		dict.Set(core.PdfObjectName("Type"), core.MakeName("ObjStm"))
		n := int64(ostreams.Len())
		dict.Set(core.PdfObjectName("N"), core.MakeInteger(n))
		first := int64(len(offsetsStr))
		dict.Set(core.PdfObjectName("First"), core.MakeInteger(first))

		data, _ := encoder.EncodeBytes([]byte(offsetsStr + objData))
		length := int64(len(data))

		dict.Set(core.PdfObjectName("Length"), core.MakeInteger(length))
		outStr += dict.WriteString()
		outStr += "\nstream\n"
		w.writeString(outStr)
		w.writeBytes(data)
		w.writeString("\nendstream\nendobj\n")
		return
	}

	w.writeString(obj.WriteString())
}

// Update all the object numbers prior to writing.
func (w *PdfWriter) updateObjectNumbers() {
	offset := w.ObjNumOffset

	// Update numbers
	i := 0
	for _, obj := range w.objects {
		objNum := int64(i + 1 + offset)
		increase := true
		if w.appendMode {
			if replaceNum, has := w.appendReplaceMap[obj]; has {
				objNum = replaceNum
				increase = false
			}
		}

		switch o := obj.(type) {
		case *core.PdfIndirectObject:
			o.ObjectNumber = objNum
			o.GenerationNumber = 0
		case *core.PdfObjectStream:
			o.ObjectNumber = objNum
			o.GenerationNumber = 0
		case *core.PdfObjectStreams:
			o.ObjectNumber = objNum
			o.GenerationNumber = 0
		default:
			common.Log.Debug("ERROR: Unknown type %T - skipping", o)
			continue
		}

		if increase {
			i++
		}
	}

	getObjNum := func(obj core.PdfObject) int64 {
		switch o := obj.(type) {
		case *core.PdfIndirectObject:
			return o.ObjectNumber
		case *core.PdfObjectStream:
			return o.ObjectNumber
		case *core.PdfObjectStreams:
			return o.ObjectNumber
		}
		return 0
	}
	// Sort the output by object numbers so that they appear in descending order.
	sort.SliceStable(w.objects, func(i, j int) bool {
		return getObjNum(w.objects[i]) < getObjNum(w.objects[j])
	})
}

// EncryptOptions represents encryption options for an output PDF.
type EncryptOptions struct {
	Permissions security.Permissions
	Algorithm   EncryptionAlgorithm
}

// EncryptionAlgorithm is used in EncryptOptions to change the default algorithm used to encrypt the document.
type EncryptionAlgorithm int

const (
	// RC4_128bit uses RC4 encryption (128 bit)
	RC4_128bit = EncryptionAlgorithm(iota)
	// AES_128bit uses AES encryption (128 bit, PDF 1.6)
	AES_128bit
	// AES_256bit uses AES encryption (256 bit, PDF 2.0)
	AES_256bit
)

// Encrypt encrypts the output file with a specified user/owner password.
func (w *PdfWriter) Encrypt(userPass, ownerPass []byte, options *EncryptOptions) error {
	algo := RC4_128bit
	if options != nil {
		algo = options.Algorithm
	}
	perm := security.PermOwner
	if options != nil {
		perm = options.Permissions
	}

	var cf crypt.Filter
	switch algo {
	case RC4_128bit:
		cf = crypt.NewFilterV2(16)
	case AES_128bit:
		cf = crypt.NewFilterAESV2()
	case AES_256bit:
		cf = crypt.NewFilterAESV3()
	default:
		return fmt.Errorf("unsupported algorithm: %v", options.Algorithm)
	}
	crypter, info, err := core.PdfCryptNewEncrypt(cf, userPass, ownerPass, perm)
	if err != nil {
		return err
	}
	w.crypter = crypter
	if info.Major != 0 {
		w.SetVersion(info.Major, info.Minor)
	}
	w.encryptDict = info.Encrypt

	w.ids = core.MakeArray(core.MakeHexString(info.ID0), core.MakeHexString(info.ID1))

	// Make an object to contain the encryption dictionary.
	io := core.MakeIndirectObject(info.Encrypt)
	w.encryptObj = io
	w.addObject(io)

	return nil
}

// Wrapper function to handle writing out string.
func (w *PdfWriter) writeString(s string) {
	if w.werr != nil {
		return
	}
	n, err := w.writer.WriteString(s)
	w.writePos += int64(n)
	w.werr = err
}

// Wrapper function to handle writing out bytes.
func (w *PdfWriter) writeBytes(bb []byte) {
	if w.werr != nil {
		return
	}
	n, err := w.writer.Write(bb)
	w.writePos += int64(n)
	w.werr = err
}

// Write writes out the PDF.
func (w *PdfWriter) Write(writer io.Writer) error {
	common.Log.Trace("Write()")

	lk := license.GetLicenseKey()
	if lk == nil || !lk.IsLicensed() {
		fmt.Printf("Unlicensed copy of unidoc\n")
		fmt.Printf("To get rid of the watermark - Please get a license on https://unidoc.io\n")
	}

	// Outlines.
	if w.outlineTree != nil {
		common.Log.Trace("OutlineTree: %+v", w.outlineTree)
		outlines := w.outlineTree.ToPdfObject()
		common.Log.Trace("Outlines: %+v (%T, p:%p)", outlines, outlines, outlines)
		w.catalog.Set("Outlines", outlines)
		err := w.addObjects(outlines)
		if err != nil {
			return err
		}
	}

	// Form fields.
	if w.acroForm != nil {
		common.Log.Trace("Writing acro forms")
		indObj := w.acroForm.ToPdfObject()
		common.Log.Trace("AcroForm: %+v", indObj)
		w.catalog.Set("AcroForm", indObj)
		err := w.addObjects(indObj)
		if err != nil {
			return err
		}
	}

	// Check pending objects prior to write.
	for pendingObj, pendingObjDicts := range w.pendingObjects {
		if !w.hasObject(pendingObj) {
			common.Log.Debug("WARN Pending object %+v %T (%p) never added for writing", pendingObj, pendingObj, pendingObj)
			for _, pendingObjDict := range pendingObjDicts {
				for _, key := range pendingObjDict.Keys() {
					val := pendingObjDict.Get(key)
					if val == pendingObj {
						common.Log.Debug("Pending object found! and replaced with null")
						pendingObjDict.Set(key, core.MakeNull())
						break
					}
				}
			}
		}
	}
	// Set version in the catalog.
	w.catalog.Set("Version", core.MakeName(fmt.Sprintf("%d.%d", w.majorVersion, w.minorVersion)))

	// Make a copy of objects prior to optimizing as this can alter the objects.
	// TODO: Copying wastes memory. Might be worth making user responsible for handling properly.
	//       Is copy needed for optimization?
	w.copyObjects()

	if w.optimizer != nil {
		var err error
		w.objects, err = w.optimizer.Optimize(w.objects)
		if err != nil {
			return err
		}
		objMap := make(map[core.PdfObject]struct{}, len(w.objects))
		for _, obj := range w.objects {
			objMap[obj] = struct{}{}
		}
		w.objectsMap = objMap
	}

	w.writePos = w.writeOffset
	w.writer = bufio.NewWriter(writer)
	useCrossReferenceStream := w.majorVersion > 1 || (w.majorVersion == 1 && w.minorVersion > 4)
	if w.useCrossReferenceStream != nil {
		useCrossReferenceStream = *w.useCrossReferenceStream
	}

	// Make a map of objects within object streams (if used).
	objectsInObjectStreams := make(map[core.PdfObject]bool)
	for _, obj := range w.objects {
		if objStm, isObjectStreams := obj.(*core.PdfObjectStreams); isObjectStreams {
			// Objects in object streams can only be referenced from an xref stream (not table).
			useCrossReferenceStream = true
			for _, obj := range objStm.Elements() {
				objectsInObjectStreams[obj] = true
				if io, isIndirectObj := obj.(*core.PdfIndirectObject); isIndirectObj {
					objectsInObjectStreams[io.PdfObject] = true
				}
			}
		}
	}

	if useCrossReferenceStream && w.majorVersion == 1 && w.minorVersion < 5 {
		w.minorVersion = 5
	}

	if w.appendMode {
		w.writeString("\n")
	} else {
		w.writeString(fmt.Sprintf("%%PDF-%d.%d\n", w.majorVersion, w.minorVersion))
		w.writeString("%âãÏÓ\n")
	}

	w.updateObjectNumbers()

	// Write objects
	common.Log.Trace("Writing %d obj", len(w.objects))
	w.crossReferenceMap = make(map[int]crossReference)
	w.crossReferenceMap[0] = crossReference{Type: 0, ObjectNumber: 0, Generation: 0xFFFF}
	if w.appendToXrefs.ObjectMap != nil {
		for idx, xref := range w.appendToXrefs.ObjectMap {
			if idx == 0 {
				continue
			}
			if xref.XType == core.XrefTypeObjectStream {
				cr := crossReference{Type: 2, ObjectNumber: xref.OsObjNumber, Index: xref.OsObjIndex}
				w.crossReferenceMap[idx] = cr
			}
			if xref.XType == core.XrefTypeTableEntry {
				cr := crossReference{Type: 1, ObjectNumber: xref.ObjectNumber, Offset: xref.Offset}
				w.crossReferenceMap[idx] = cr
			}
		}
	}

	// Write out indirect/stream objects that are not in object streams.
	for _, obj := range w.objects {
		if skip := objectsInObjectStreams[obj]; skip {
			continue
		}

		objectNumber := int64(0)
		switch t := obj.(type) {
		case *core.PdfIndirectObject:
			objectNumber = t.ObjectNumber
		case *core.PdfObjectStream:
			objectNumber = t.ObjectNumber
		case *core.PdfObjectStreams:
			objectNumber = t.ObjectNumber
		default:
			common.Log.Debug("ERROR: Unsupported type in writer objects: %T", obj)
			return ErrTypeCheck
		}

		// Encrypt prior to writing.
		// Encrypt dictionary should not be encrypted.
		if w.crypter != nil && obj != w.encryptObj {
			err := w.crypter.Encrypt(obj, int64(objectNumber), 0)
			if err != nil {
				common.Log.Debug("ERROR: Failed encrypting (%s)", err)
				return err
			}
		}
		w.writeObject(int(objectNumber), obj)
	}

	xrefOffset := w.writePos
	var maxIndex int
	for idx := range w.crossReferenceMap {
		if idx > maxIndex {
			maxIndex = idx
		}
	}

	// Write trailer / cross reference stream (depending on which used).
	if useCrossReferenceStream {
		crossObjNumber := maxIndex + 1
		w.crossReferenceMap[crossObjNumber] = crossReference{Type: 1, ObjectNumber: crossObjNumber, Offset: xrefOffset}
		crossReferenceData := bytes.NewBuffer(nil)

		index := core.MakeArray()
		for idx := 0; idx <= maxIndex; {
			// Find next to write.
			for ; idx <= maxIndex; idx++ {
				ref, has := w.crossReferenceMap[idx]
				if has && (!w.appendMode || w.appendMode && (ref.Type == 1 && ref.Offset >= w.appendPrevRevisionSize || ref.Type == 0)) {
					break
				}
			}

			var j int
			for j = idx + 1; j <= maxIndex; j++ {
				ref, has := w.crossReferenceMap[j]
				if has && (!w.appendMode || w.appendMode && (ref.Type == 1 && ref.Offset > w.appendPrevRevisionSize)) {
					continue
				}
				break
			}
			index.Append(core.MakeInteger(int64(idx)), core.MakeInteger(int64(j-idx)))

			for k := idx; k < j; k++ {
				ref := w.crossReferenceMap[k]
				switch ref.Type {
				case 0:
					binary.Write(crossReferenceData, binary.BigEndian, byte(0))
					binary.Write(crossReferenceData, binary.BigEndian, uint32(0))
					binary.Write(crossReferenceData, binary.BigEndian, uint16(0xFFFF))
				case 1:
					binary.Write(crossReferenceData, binary.BigEndian, byte(1))
					binary.Write(crossReferenceData, binary.BigEndian, uint32(ref.Offset))
					binary.Write(crossReferenceData, binary.BigEndian, uint16(ref.Generation))
				case 2:
					binary.Write(crossReferenceData, binary.BigEndian, byte(2))
					binary.Write(crossReferenceData, binary.BigEndian, uint32(ref.ObjectNumber))
					binary.Write(crossReferenceData, binary.BigEndian, uint16(ref.Index))
				}
			}

			idx = j + 1
		}

		crossReferenceStream, err := core.MakeStream(crossReferenceData.Bytes(), core.NewFlateEncoder())
		if err != nil {
			return err
		}
		crossReferenceStream.ObjectNumber = int64(crossObjNumber)
		crossReferenceStream.PdfObjectDictionary.Set("Type", core.MakeName("XRef"))
		crossReferenceStream.PdfObjectDictionary.Set("W", core.MakeArray(core.MakeInteger(1), core.MakeInteger(4), core.MakeInteger(2)))
		crossReferenceStream.PdfObjectDictionary.Set("Index", index)
		crossReferenceStream.PdfObjectDictionary.Set("Size", core.MakeInteger(int64(crossObjNumber+1)))
		crossReferenceStream.PdfObjectDictionary.Set("Info", w.infoObj)
		crossReferenceStream.PdfObjectDictionary.Set("Root", w.root)
		if w.appendMode && w.appendXrefPrevOffset > 0 {
			crossReferenceStream.PdfObjectDictionary.Set("Prev", core.MakeInteger(w.appendXrefPrevOffset))
		}
		// If encrypted!
		if w.crypter != nil {
			crossReferenceStream.Set("Encrypt", w.encryptObj)
			crossReferenceStream.Set("ID", w.ids)
			common.Log.Trace("Ids: %s", w.ids)
		}

		w.writeObject(int(crossReferenceStream.ObjectNumber), crossReferenceStream)
	} else {
		w.writeString("xref\r\n")
		for idx := 0; idx <= maxIndex; {
			// Find next to write.
			for ; idx <= maxIndex; idx++ {
				ref, has := w.crossReferenceMap[idx]
				if has && (!w.appendMode || w.appendMode && (ref.Type == 1 && ref.Offset >= w.appendPrevRevisionSize || ref.Type == 0)) {
					break
				}
			}

			var j int
			for j = idx + 1; j <= maxIndex; j++ {
				ref, has := w.crossReferenceMap[j]
				if has && (!w.appendMode || w.appendMode && (ref.Type == 1 && ref.Offset > w.appendPrevRevisionSize)) {
					continue
				}
				break
			}

			outStr := fmt.Sprintf("%d %d\r\n", idx, j-idx)
			w.writeString(outStr)
			for k := idx; k < j; k++ {
				ref := w.crossReferenceMap[k]
				switch ref.Type {
				case 0:
					outStr = fmt.Sprintf("%.10d %.5d f\r\n", 0, 65535)
					w.writeString(outStr)
				case 1:
					outStr = fmt.Sprintf("%.10d %.5d n\r\n", ref.Offset, 0)
					w.writeString(outStr)
				}
			}

			idx = j + 1
		}

		// Generate & write trailer
		trailer := core.MakeDict()
		trailer.Set("Info", w.infoObj)
		trailer.Set("Root", w.root)
		trailer.Set("Size", core.MakeInteger(int64(maxIndex+1)))
		if w.appendMode && w.appendXrefPrevOffset > 0 {
			trailer.Set("Prev", core.MakeInteger(w.appendXrefPrevOffset))
		}
		// If encrypted!
		if w.crypter != nil {
			trailer.Set("Encrypt", w.encryptObj)
			trailer.Set("ID", w.ids)
			common.Log.Trace("Ids: %s", w.ids)
		} else if getIsPDFA() {
			// XXX:(peterwilliams97). PDF/A requires ID to be set.
			// The PDF spec says
			// File identifiers shall be defined by the optional ID entry in a PDF file’s trailer
			// dictionary (see 7.5.5, “File Trailer”). The ID entry is optional but should be used.
			// The value of this entry shall be an array of two byte strings. The first byte string
			// shall be a permanent identifier based on the contents of the file at the time it was
			// originally created and shall not change when the file is incrementally updated. The
			// second byte string shall be a changing identifier based on the file’s contents at the
			// time it was last updated.
			// When a file is first written, both identifiers shall be set to the same value.
			// TODO(peterwilliams97): Compute first string from a file hasb.
			if w.ids != nil {
				trailer.Set("ID", w.ids)
			} else {
				b := make([]byte, 100)
				rand.Read(b)
				hash1 := md5.Sum(b)
				id := core.MakeHexString(string(hash1[:]))
				trailer.Set("ID", core.MakeArray(id, id))
			}
		}
		w.writeString("trailer\n")
		w.writeString(trailer.WriteString())
		w.writeString("\n")
	}

	// Make offset reference.
	outStr := fmt.Sprintf("startxref\n%d\n", xrefOffset)
	w.writeString(outStr)
	w.writeString("%%EOF\n")

	if w.werr == nil {
		w.werr = w.writer.Flush()
	}

	return w.werr
}

// documentMetadataStream returns a PDF/A1-b /Metadata stream object.
func documentMetadataStream() (core.PdfObject, error) {
	contents, err := documentMetadataContents()
	if err != nil {
		return nil, err
	}
	// Metadata object stream dictionaries shall not contain the Filter key,
	stream, err := core.MakeStream(contents, nil)
	if err != nil {
		return nil, err
	}
	stream.Set("Type", core.MakeName("Metadata"))
	stream.Set("Subtype", core.MakeName("XML"))
	return stream, nil
}

// documentMetadataContents returnn the xmp data for a PDF/A1-b /Metadata stream object.
func documentMetadataContents() ([]byte, error) {
	var b bytes.Buffer
	wrt := func(src string, args ...interface{}) { b.Write([]byte(fmt.Sprintf(src, args...) + "\n")) }
	wrtIf := func(src, val string) {
		if len(val) > 0 {
			wrt(src, val)
		}
	}

	wrt(`<?xpacket begin='ï»¿' id='W5M0MpCehiHzreSzNTczkc9d'?>`)
	wrt("<?adobe-xap-filters esc=\"CRLF\"?>")
	wrt("<x:xmpmeta xmlns:x='adobe:ns:meta/' x:xmptk='XMP toolkit 2.9.1-13, framework 1.6'>")
	wrt("<rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#' xmlns:iX='http://ns.adobe.com/iX/1.0/'>")
	wrt(`<rdf:Description rdf:about="" xmlns:xapMM='http://ns.adobe.com/xap/1.0/mm/' xapMM:DocumentID='%s'/>`, documentUUID())
	wrt(`<rdf:Description rdf:about="" xmlns:pdfaid='http://www.aiim.org/pdfa/ns/id/' pdfaid:part='1' pdfaid:conformance='B'/>`)
	wrt(`<rdf:Description rdf:about="" xmlns:pdf='http://ns.adobe.com/pdf/1.3/' pdf:Producer='%s'/>`, getPdfProducer())
	wrtIf(`<rdf:Description rdf:about="" xmlns:pdf='http://ns.adobe.com/pdf/1.3/' pdf:Keywords='%s'/>`, getPdfKeywords())
	wrt(`<rdf:Description rdf:about="" xmlns:xmp='http://ns.adobe.com/xap/1.0/'>`)
	wrt("<xmp:ModifyDate>%s</xmp:ModifyDate>", xmpTime(getPdfModifiedDate()))
	wrt("<xmp:CreateDate>%s</xmp:CreateDate>", xmpTime(getPdfCreationDate()))
	wrt("<xmp:CreatorTool>%s</xmp:CreatorTool>", getPdfCreator())
	wrt("</rdf:Description>")
	wrt(`<rdf:Description rdf:about="" xmlns:dc='http://purl.org/dc/elements/1.1/' dc:format='application/pdf'>`)
	wrtIf("<dc:title><rdf:Alt><rdf:li xml:lang='x-default'>%s</rdf:li></rdf:Alt></dc:title>", getPdfTitle())
	wrtIf("<dc:description><rdf:Alt><rdf:li xml:lang='x-default'>%s</rdf:li></rdf:Alt></dc:description>", getPdfSubject())
	wrtIf("<dc:creator><rdf:Seq><rdf:li xml:lang='x-default'>%s</rdf:li></rdf:Seq></dc:creator>", getPdfAuthor())
	wrt("</rdf:Description>")
	wrt(`</rdf:RDF>`)
	wrt(`</x:xmpmeta>`)
	wrt(`<?xpacket end='w'?>`)

	return b.Bytes(), nil
}

// documentUUID returns an xmp document UUID based on random number.
func documentUUID() string {
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	n0 := r.Uint64()
	n1 := r.Uint64()
	n2 := r.Uint64()
	n3 := r.Uint64()
	return makeUUID(n0, n1, n2, n3)
}

// makeUUID returns a UUID based on the numbers n0, n1, n2 and n3.
// It has the form  uuid:4c7ed054-b808-594d-0000-859c2ececc82
func makeUUID(n0, n1, n2, n3 uint64) string {
	return fmt.Sprintf("uuid:%08x-%04x-%04x-0000-%012x",
		n0%0xffffffff,
		n1%0xffff,
		n2%0xffff,
		n3%0xffffffffffff)
}

// xmpTime returns `dateTime` in xmp format.
func xmpTime(dateTime time.Time) string {
	return dateTime.Format("2006-01-02T15:04:05Z07:00")
}

// outputIntentStream returns iccProfile, outputIntent
// where
//  iccProfile is a profile binary stream for sRGB
//  outputIntent is a output intent stream for sRGB.
// 5 0 obj
// [<</Type /OutputIntent/S /GTS_PDFA1/Info (sRGB IEC61966-2.1)/OutputCondition (sRGB)/OutputConditionIdentifier (Custom)/RegistryName ()/DestOutputProfile 6 0 R>>]
// endobj
// Safe depiction of colors in PDF/A
// - If device-dependent colors are used, an output intent must be specified.
// - If there is already a source profile for all colors used, there is no need to specify an output intent.
// - If an output intent is used, if must have one output profile only.
// - Objects such as images and graphics can exist in different color spaces (RGB, CMYK, spot colors,
//   grayscale and Lab).
// - It is also possible to use a single device-dependent color space (with no ICC profile).
// - Device-dependent CMYK and device-dependent RGB may not be used together. If device-dependent colors
//   are used, there must be an output intent for the same color space (RGB, CMYK, or Gray). However, only one
//   output intent color
func outputIntentStream() (core.PdfObject, core.PdfObject, error) {
	iccProfile, err := core.MakeStream(iccProfileSRGB, core.NewFlateEncoder())
	if err != nil {
		common.Log.Error("Could not create iccProfile. err=%v", err)
		return nil, nil, err
	}
	iccProfile.Set("N", core.MakeInteger(3))
	iccProfile.Set("Range", core.MakeArrayFromFloats([]float64{0, 1, 0, 1, 0, 1}))
	outputIntent := outputIntentDict(iccProfile)
	return iccProfile, outputIntent, nil
}

// outputIntentDict returns a sRGB OutputIntent for PDF/A.
func outputIntentDict(profile core.PdfObject) core.PdfObject {
	dict := core.MakeDict()
	dict.Set("Type", core.MakeName("OutputIntent"))
	dict.Set("S", core.MakeName("GTS_PDFA1"))
	dict.Set("Info", core.MakeString("sRGB IEC61966-2.1"))
	dict.Set("OutputCondition", core.MakeString("sRGB"))
	dict.Set("OutputConditionIdentifier", core.MakeString("Custom"))
	dict.Set("RegistryName", core.MakeString(""))
	dict.Set("DestOutputProfile", profile)
	return dict
}

// iccProfileSRGB is ICC profile binary for sRGB IEC61966-2.1
var iccProfileSRGB = []byte{0x0, 0x0, 0xc, 0x48, 0x4c, 0x69, 0x6e, 0x6f, 0x2, 0x10, 0x0, 0x0, 0x6d, 0x6e, 0x74, 0x72, 0x52, 0x47, 0x42, 0x20, 0x58, 0x59, 0x5a, 0x20, 0x7, 0xce, 0x0, 0x2, 0x0, 0x9, 0x0, 0x6, 0x0, 0x31, 0x0, 0x0, 0x61, 0x63, 0x73, 0x70, 0x4d, 0x53, 0x46, 0x54, 0x0, 0x0, 0x0, 0x0, 0x49, 0x45, 0x43, 0x20, 0x73, 0x52, 0x47, 0x42, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf6, 0xd6, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0xd3, 0x2d, 0x48, 0x50, 0x20, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11, 0x63, 0x70, 0x72, 0x74, 0x0, 0x0, 0x1, 0x50, 0x0, 0x0, 0x0, 0x33, 0x64, 0x65, 0x73, 0x63, 0x0, 0x0, 0x1, 0x84, 0x0, 0x0, 0x0, 0x6c, 0x77, 0x74, 0x70, 0x74, 0x0, 0x0, 0x1, 0xf0, 0x0, 0x0, 0x0, 0x14, 0x62, 0x6b, 0x70, 0x74, 0x0, 0x0, 0x2, 0x4, 0x0, 0x0, 0x0, 0x14, 0x72, 0x58, 0x59, 0x5a, 0x0, 0x0, 0x2, 0x18, 0x0, 0x0, 0x0, 0x14, 0x67, 0x58, 0x59, 0x5a, 0x0, 0x0, 0x2, 0x2c, 0x0, 0x0, 0x0, 0x14, 0x62, 0x58, 0x59, 0x5a, 0x0, 0x0, 0x2, 0x40, 0x0, 0x0, 0x0, 0x14, 0x64, 0x6d, 0x6e, 0x64, 0x0, 0x0, 0x2, 0x54, 0x0, 0x0, 0x0, 0x70, 0x64, 0x6d, 0x64, 0x64, 0x0, 0x0, 0x2, 0xc4, 0x0, 0x0, 0x0, 0x88, 0x76, 0x75, 0x65, 0x64, 0x0, 0x0, 0x3, 0x4c, 0x0, 0x0, 0x0, 0x86, 0x76, 0x69, 0x65, 0x77, 0x0, 0x0, 0x3, 0xd4, 0x0, 0x0, 0x0, 0x24, 0x6c, 0x75, 0x6d, 0x69, 0x0, 0x0, 0x3, 0xf8, 0x0, 0x0, 0x0, 0x14, 0x6d, 0x65, 0x61, 0x73, 0x0, 0x0, 0x4, 0xc, 0x0, 0x0, 0x0, 0x24, 0x74, 0x65, 0x63, 0x68, 0x0, 0x0, 0x4, 0x30, 0x0, 0x0, 0x0, 0xc, 0x72, 0x54, 0x52, 0x43, 0x0, 0x0, 0x4, 0x3c, 0x0, 0x0, 0x8, 0xc, 0x67, 0x54, 0x52, 0x43, 0x0, 0x0, 0x4, 0x3c, 0x0, 0x0, 0x8, 0xc, 0x62, 0x54, 0x52, 0x43, 0x0, 0x0, 0x4, 0x3c, 0x0, 0x0, 0x8, 0xc, 0x74, 0x65, 0x78, 0x74, 0x0, 0x0, 0x0, 0x0, 0x43, 0x6f, 0x70, 0x79, 0x72, 0x69, 0x67, 0x68, 0x74, 0x20, 0x28, 0x63, 0x29, 0x20, 0x31, 0x39, 0x39, 0x38, 0x20, 0x48, 0x65, 0x77, 0x6c, 0x65, 0x74, 0x74, 0x2d, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x72, 0x64, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x61, 0x6e, 0x79, 0x0, 0x0, 0x64, 0x65, 0x73, 0x63, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x12, 0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x12, 0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x58, 0x59, 0x5a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf3, 0x51, 0x0, 0x1, 0x0, 0x0, 0x0, 0x1, 0x16, 0xcc, 0x58, 0x59, 0x5a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x58, 0x59, 0x5a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6f, 0xa2, 0x0, 0x0, 0x38, 0xf5, 0x0, 0x0, 0x3, 0x90, 0x58, 0x59, 0x5a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x62, 0x99, 0x0, 0x0, 0xb7, 0x85, 0x0, 0x0, 0x18, 0xda, 0x58, 0x59, 0x5a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x24, 0xa0, 0x0, 0x0, 0xf, 0x84, 0x0, 0x0, 0xb6, 0xcf, 0x64, 0x65, 0x73, 0x63, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x16, 0x49, 0x45, 0x43, 0x20, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x69, 0x65, 0x63, 0x2e, 0x63, 0x68, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x16, 0x49, 0x45, 0x43, 0x20, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x69, 0x65, 0x63, 0x2e, 0x63, 0x68, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x64, 0x65, 0x73, 0x63, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2e, 0x49, 0x45, 0x43, 0x20, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x52, 0x47, 0x42, 0x20, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x2d, 0x20, 0x73, 0x52, 0x47, 0x42, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2e, 0x49, 0x45, 0x43, 0x20, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x52, 0x47, 0x42, 0x20, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20, 0x2d, 0x20, 0x73, 0x52, 0x47, 0x42, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x64, 0x65, 0x73, 0x63, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2c, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x56, 0x69, 0x65, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x6e, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2c, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x20, 0x56, 0x69, 0x65, 0x77, 0x69, 0x6e, 0x67, 0x20, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x6e, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x76, 0x69, 0x65, 0x77, 0x0, 0x0, 0x0, 0x0, 0x0, 0x13, 0xa4, 0xfe, 0x0, 0x14, 0x5f, 0x2e, 0x0, 0x10, 0xcf, 0x14, 0x0, 0x3, 0xed, 0xcc, 0x0, 0x4, 0x13, 0xb, 0x0, 0x3, 0x5c, 0x9e, 0x0, 0x0, 0x0, 0x1, 0x58, 0x59, 0x5a, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4c, 0x9, 0x56, 0x0, 0x50, 0x0, 0x0, 0x0, 0x57, 0x1f, 0xe7, 0x6d, 0x65, 0x61, 0x73, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x8f, 0x0, 0x0, 0x0, 0x2, 0x73, 0x69, 0x67, 0x20, 0x0, 0x0, 0x0, 0x0, 0x43, 0x52, 0x54, 0x20, 0x63, 0x75, 0x72, 0x76, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x5, 0x0, 0xa, 0x0, 0xf, 0x0, 0x14, 0x0, 0x19, 0x0, 0x1e, 0x0, 0x23, 0x0, 0x28, 0x0, 0x2d, 0x0, 0x32, 0x0, 0x37, 0x0, 0x3b, 0x0, 0x40, 0x0, 0x45, 0x0, 0x4a, 0x0, 0x4f, 0x0, 0x54, 0x0, 0x59, 0x0, 0x5e, 0x0, 0x63, 0x0, 0x68, 0x0, 0x6d, 0x0, 0x72, 0x0, 0x77, 0x0, 0x7c, 0x0, 0x81, 0x0, 0x86, 0x0, 0x8b, 0x0, 0x90, 0x0, 0x95, 0x0, 0x9a, 0x0, 0x9f, 0x0, 0xa4, 0x0, 0xa9, 0x0, 0xae, 0x0, 0xb2, 0x0, 0xb7, 0x0, 0xbc, 0x0, 0xc1, 0x0, 0xc6, 0x0, 0xcb, 0x0, 0xd0, 0x0, 0xd5, 0x0, 0xdb, 0x0, 0xe0, 0x0, 0xe5, 0x0, 0xeb, 0x0, 0xf0, 0x0, 0xf6, 0x0, 0xfb, 0x1, 0x1, 0x1, 0x7, 0x1, 0xd, 0x1, 0x13, 0x1, 0x19, 0x1, 0x1f, 0x1, 0x25, 0x1, 0x2b, 0x1, 0x32, 0x1, 0x38, 0x1, 0x3e, 0x1, 0x45, 0x1, 0x4c, 0x1, 0x52, 0x1, 0x59, 0x1, 0x60, 0x1, 0x67, 0x1, 0x6e, 0x1, 0x75, 0x1, 0x7c, 0x1, 0x83, 0x1, 0x8b, 0x1, 0x92, 0x1, 0x9a, 0x1, 0xa1, 0x1, 0xa9, 0x1, 0xb1, 0x1, 0xb9, 0x1, 0xc1, 0x1, 0xc9, 0x1, 0xd1, 0x1, 0xd9, 0x1, 0xe1, 0x1, 0xe9, 0x1, 0xf2, 0x1, 0xfa, 0x2, 0x3, 0x2, 0xc, 0x2, 0x14, 0x2, 0x1d, 0x2, 0x26, 0x2, 0x2f, 0x2, 0x38, 0x2, 0x41, 0x2, 0x4b, 0x2, 0x54, 0x2, 0x5d, 0x2, 0x67, 0x2, 0x71, 0x2, 0x7a, 0x2, 0x84, 0x2, 0x8e, 0x2, 0x98, 0x2, 0xa2, 0x2, 0xac, 0x2, 0xb6, 0x2, 0xc1, 0x2, 0xcb, 0x2, 0xd5, 0x2, 0xe0, 0x2, 0xeb, 0x2, 0xf5, 0x3, 0x0, 0x3, 0xb, 0x3, 0x16, 0x3, 0x21, 0x3, 0x2d, 0x3, 0x38, 0x3, 0x43, 0x3, 0x4f, 0x3, 0x5a, 0x3, 0x66, 0x3, 0x72, 0x3, 0x7e, 0x3, 0x8a, 0x3, 0x96, 0x3, 0xa2, 0x3, 0xae, 0x3, 0xba, 0x3, 0xc7, 0x3, 0xd3, 0x3, 0xe0, 0x3, 0xec, 0x3, 0xf9, 0x4, 0x6, 0x4, 0x13, 0x4, 0x20, 0x4, 0x2d, 0x4, 0x3b, 0x4, 0x48, 0x4, 0x55, 0x4, 0x63, 0x4, 0x71, 0x4, 0x7e, 0x4, 0x8c, 0x4, 0x9a, 0x4, 0xa8, 0x4, 0xb6, 0x4, 0xc4, 0x4, 0xd3, 0x4, 0xe1, 0x4, 0xf0, 0x4, 0xfe, 0x5, 0xd, 0x5, 0x1c, 0x5, 0x2b, 0x5, 0x3a, 0x5, 0x49, 0x5, 0x58, 0x5, 0x67, 0x5, 0x77, 0x5, 0x86, 0x5, 0x96, 0x5, 0xa6, 0x5, 0xb5, 0x5, 0xc5, 0x5, 0xd5, 0x5, 0xe5, 0x5, 0xf6, 0x6, 0x6, 0x6, 0x16, 0x6, 0x27, 0x6, 0x37, 0x6, 0x48, 0x6, 0x59, 0x6, 0x6a, 0x6, 0x7b, 0x6, 0x8c, 0x6, 0x9d, 0x6, 0xaf, 0x6, 0xc0, 0x6, 0xd1, 0x6, 0xe3, 0x6, 0xf5, 0x7, 0x7, 0x7, 0x19, 0x7, 0x2b, 0x7, 0x3d, 0x7, 0x4f, 0x7, 0x61, 0x7, 0x74, 0x7, 0x86, 0x7, 0x99, 0x7, 0xac, 0x7, 0xbf, 0x7, 0xd2, 0x7, 0xe5, 0x7, 0xf8, 0x8, 0xb, 0x8, 0x1f, 0x8, 0x32, 0x8, 0x46, 0x8, 0x5a, 0x8, 0x6e, 0x8, 0x82, 0x8, 0x96, 0x8, 0xaa, 0x8, 0xbe, 0x8, 0xd2, 0x8, 0xe7, 0x8, 0xfb, 0x9, 0x10, 0x9, 0x25, 0x9, 0x3a, 0x9, 0x4f, 0x9, 0x64, 0x9, 0x79, 0x9, 0x8f, 0x9, 0xa4, 0x9, 0xba, 0x9, 0xcf, 0x9, 0xe5, 0x9, 0xfb, 0xa, 0x11, 0xa, 0x27, 0xa, 0x3d, 0xa, 0x54, 0xa, 0x6a, 0xa, 0x81, 0xa, 0x98, 0xa, 0xae, 0xa, 0xc5, 0xa, 0xdc, 0xa, 0xf3, 0xb, 0xb, 0xb, 0x22, 0xb, 0x39, 0xb, 0x51, 0xb, 0x69, 0xb, 0x80, 0xb, 0x98, 0xb, 0xb0, 0xb, 0xc8, 0xb, 0xe1, 0xb, 0xf9, 0xc, 0x12, 0xc, 0x2a, 0xc, 0x43, 0xc, 0x5c, 0xc, 0x75, 0xc, 0x8e, 0xc, 0xa7, 0xc, 0xc0, 0xc, 0xd9, 0xc, 0xf3, 0xd, 0xd, 0xd, 0x26, 0xd, 0x40, 0xd, 0x5a, 0xd, 0x74, 0xd, 0x8e, 0xd, 0xa9, 0xd, 0xc3, 0xd, 0xde, 0xd, 0xf8, 0xe, 0x13, 0xe, 0x2e, 0xe, 0x49, 0xe, 0x64, 0xe, 0x7f, 0xe, 0x9b, 0xe, 0xb6, 0xe, 0xd2, 0xe, 0xee, 0xf, 0x9, 0xf, 0x25, 0xf, 0x41, 0xf, 0x5e, 0xf, 0x7a, 0xf, 0x96, 0xf, 0xb3, 0xf, 0xcf, 0xf, 0xec, 0x10, 0x9, 0x10, 0x26, 0x10, 0x43, 0x10, 0x61, 0x10, 0x7e, 0x10, 0x9b, 0x10, 0xb9, 0x10, 0xd7, 0x10, 0xf5, 0x11, 0x13, 0x11, 0x31, 0x11, 0x4f, 0x11, 0x6d, 0x11, 0x8c, 0x11, 0xaa, 0x11, 0xc9, 0x11, 0xe8, 0x12, 0x7, 0x12, 0x26, 0x12, 0x45, 0x12, 0x64, 0x12, 0x84, 0x12, 0xa3, 0x12, 0xc3, 0x12, 0xe3, 0x13, 0x3, 0x13, 0x23, 0x13, 0x43, 0x13, 0x63, 0x13, 0x83, 0x13, 0xa4, 0x13, 0xc5, 0x13, 0xe5, 0x14, 0x6, 0x14, 0x27, 0x14, 0x49, 0x14, 0x6a, 0x14, 0x8b, 0x14, 0xad, 0x14, 0xce, 0x14, 0xf0, 0x15, 0x12, 0x15, 0x34, 0x15, 0x56, 0x15, 0x78, 0x15, 0x9b, 0x15, 0xbd, 0x15, 0xe0, 0x16, 0x3, 0x16, 0x26, 0x16, 0x49, 0x16, 0x6c, 0x16, 0x8f, 0x16, 0xb2, 0x16, 0xd6, 0x16, 0xfa, 0x17, 0x1d, 0x17, 0x41, 0x17, 0x65, 0x17, 0x89, 0x17, 0xae, 0x17, 0xd2, 0x17, 0xf7, 0x18, 0x1b, 0x18, 0x40, 0x18, 0x65, 0x18, 0x8a, 0x18, 0xaf, 0x18, 0xd5, 0x18, 0xfa, 0x19, 0x20, 0x19, 0x45, 0x19, 0x6b, 0x19, 0x91, 0x19, 0xb7, 0x19, 0xdd, 0x1a, 0x4, 0x1a, 0x2a, 0x1a, 0x51, 0x1a, 0x77, 0x1a, 0x9e, 0x1a, 0xc5, 0x1a, 0xec, 0x1b, 0x14, 0x1b, 0x3b, 0x1b, 0x63, 0x1b, 0x8a, 0x1b, 0xb2, 0x1b, 0xda, 0x1c, 0x2, 0x1c, 0x2a, 0x1c, 0x52, 0x1c, 0x7b, 0x1c, 0xa3, 0x1c, 0xcc, 0x1c, 0xf5, 0x1d, 0x1e, 0x1d, 0x47, 0x1d, 0x70, 0x1d, 0x99, 0x1d, 0xc3, 0x1d, 0xec, 0x1e, 0x16, 0x1e, 0x40, 0x1e, 0x6a, 0x1e, 0x94, 0x1e, 0xbe, 0x1e, 0xe9, 0x1f, 0x13, 0x1f, 0x3e, 0x1f, 0x69, 0x1f, 0x94, 0x1f, 0xbf, 0x1f, 0xea, 0x20, 0x15, 0x20, 0x41, 0x20, 0x6c, 0x20, 0x98, 0x20, 0xc4, 0x20, 0xf0, 0x21, 0x1c, 0x21, 0x48, 0x21, 0x75, 0x21, 0xa1, 0x21, 0xce, 0x21, 0xfb, 0x22, 0x27, 0x22, 0x55, 0x22, 0x82, 0x22, 0xaf, 0x22, 0xdd, 0x23, 0xa, 0x23, 0x38, 0x23, 0x66, 0x23, 0x94, 0x23, 0xc2, 0x23, 0xf0, 0x24, 0x1f, 0x24, 0x4d, 0x24, 0x7c, 0x24, 0xab, 0x24, 0xda, 0x25, 0x9, 0x25, 0x38, 0x25, 0x68, 0x25, 0x97, 0x25, 0xc7, 0x25, 0xf7, 0x26, 0x27, 0x26, 0x57, 0x26, 0x87, 0x26, 0xb7, 0x26, 0xe8, 0x27, 0x18, 0x27, 0x49, 0x27, 0x7a, 0x27, 0xab, 0x27, 0xdc, 0x28, 0xd, 0x28, 0x3f, 0x28, 0x71, 0x28, 0xa2, 0x28, 0xd4, 0x29, 0x6, 0x29, 0x38, 0x29, 0x6b, 0x29, 0x9d, 0x29, 0xd0, 0x2a, 0x2, 0x2a, 0x35, 0x2a, 0x68, 0x2a, 0x9b, 0x2a, 0xcf, 0x2b, 0x2, 0x2b, 0x36, 0x2b, 0x69, 0x2b, 0x9d, 0x2b, 0xd1, 0x2c, 0x5, 0x2c, 0x39, 0x2c, 0x6e, 0x2c, 0xa2, 0x2c, 0xd7, 0x2d, 0xc, 0x2d, 0x41, 0x2d, 0x76, 0x2d, 0xab, 0x2d, 0xe1, 0x2e, 0x16, 0x2e, 0x4c, 0x2e, 0x82, 0x2e, 0xb7, 0x2e, 0xee, 0x2f, 0x24, 0x2f, 0x5a, 0x2f, 0x91, 0x2f, 0xc7, 0x2f, 0xfe, 0x30, 0x35, 0x30, 0x6c, 0x30, 0xa4, 0x30, 0xdb, 0x31, 0x12, 0x31, 0x4a, 0x31, 0x82, 0x31, 0xba, 0x31, 0xf2, 0x32, 0x2a, 0x32, 0x63, 0x32, 0x9b, 0x32, 0xd4, 0x33, 0xd, 0x33, 0x46, 0x33, 0x7f, 0x33, 0xb8, 0x33, 0xf1, 0x34, 0x2b, 0x34, 0x65, 0x34, 0x9e, 0x34, 0xd8, 0x35, 0x13, 0x35, 0x4d, 0x35, 0x87, 0x35, 0xc2, 0x35, 0xfd, 0x36, 0x37, 0x36, 0x72, 0x36, 0xae, 0x36, 0xe9, 0x37, 0x24, 0x37, 0x60, 0x37, 0x9c, 0x37, 0xd7, 0x38, 0x14, 0x38, 0x50, 0x38, 0x8c, 0x38, 0xc8, 0x39, 0x5, 0x39, 0x42, 0x39, 0x7f, 0x39, 0xbc, 0x39, 0xf9, 0x3a, 0x36, 0x3a, 0x74, 0x3a, 0xb2, 0x3a, 0xef, 0x3b, 0x2d, 0x3b, 0x6b, 0x3b, 0xaa, 0x3b, 0xe8, 0x3c, 0x27, 0x3c, 0x65, 0x3c, 0xa4, 0x3c, 0xe3, 0x3d, 0x22, 0x3d, 0x61, 0x3d, 0xa1, 0x3d, 0xe0, 0x3e, 0x20, 0x3e, 0x60, 0x3e, 0xa0, 0x3e, 0xe0, 0x3f, 0x21, 0x3f, 0x61, 0x3f, 0xa2, 0x3f, 0xe2, 0x40, 0x23, 0x40, 0x64, 0x40, 0xa6, 0x40, 0xe7, 0x41, 0x29, 0x41, 0x6a, 0x41, 0xac, 0x41, 0xee, 0x42, 0x30, 0x42, 0x72, 0x42, 0xb5, 0x42, 0xf7, 0x43, 0x3a, 0x43, 0x7d, 0x43, 0xc0, 0x44, 0x3, 0x44, 0x47, 0x44, 0x8a, 0x44, 0xce, 0x45, 0x12, 0x45, 0x55, 0x45, 0x9a, 0x45, 0xde, 0x46, 0x22, 0x46, 0x67, 0x46, 0xab, 0x46, 0xf0, 0x47, 0x35, 0x47, 0x7b, 0x47, 0xc0, 0x48, 0x5, 0x48, 0x4b, 0x48, 0x91, 0x48, 0xd7, 0x49, 0x1d, 0x49, 0x63, 0x49, 0xa9, 0x49, 0xf0, 0x4a, 0x37, 0x4a, 0x7d, 0x4a, 0xc4, 0x4b, 0xc, 0x4b, 0x53, 0x4b, 0x9a, 0x4b, 0xe2, 0x4c, 0x2a, 0x4c, 0x72, 0x4c, 0xba, 0x4d, 0x2, 0x4d, 0x4a, 0x4d, 0x93, 0x4d, 0xdc, 0x4e, 0x25, 0x4e, 0x6e, 0x4e, 0xb7, 0x4f, 0x0, 0x4f, 0x49, 0x4f, 0x93, 0x4f, 0xdd, 0x50, 0x27, 0x50, 0x71, 0x50, 0xbb, 0x51, 0x6, 0x51, 0x50, 0x51, 0x9b, 0x51, 0xe6, 0x52, 0x31, 0x52, 0x7c, 0x52, 0xc7, 0x53, 0x13, 0x53, 0x5f, 0x53, 0xaa, 0x53, 0xf6, 0x54, 0x42, 0x54, 0x8f, 0x54, 0xdb, 0x55, 0x28, 0x55, 0x75, 0x55, 0xc2, 0x56, 0xf, 0x56, 0x5c, 0x56, 0xa9, 0x56, 0xf7, 0x57, 0x44, 0x57, 0x92, 0x57, 0xe0, 0x58, 0x2f, 0x58, 0x7d, 0x58, 0xcb, 0x59, 0x1a, 0x59, 0x69, 0x59, 0xb8, 0x5a, 0x7, 0x5a, 0x56, 0x5a, 0xa6, 0x5a, 0xf5, 0x5b, 0x45, 0x5b, 0x95, 0x5b, 0xe5, 0x5c, 0x35, 0x5c, 0x86, 0x5c, 0xd6, 0x5d, 0x27, 0x5d, 0x78, 0x5d, 0xc9, 0x5e, 0x1a, 0x5e, 0x6c, 0x5e, 0xbd, 0x5f, 0xf, 0x5f, 0x61, 0x5f, 0xb3, 0x60, 0x5, 0x60, 0x57, 0x60, 0xaa, 0x60, 0xfc, 0x61, 0x4f, 0x61, 0xa2, 0x61, 0xf5, 0x62, 0x49, 0x62, 0x9c, 0x62, 0xf0, 0x63, 0x43, 0x63, 0x97, 0x63, 0xeb, 0x64, 0x40, 0x64, 0x94, 0x64, 0xe9, 0x65, 0x3d, 0x65, 0x92, 0x65, 0xe7, 0x66, 0x3d, 0x66, 0x92, 0x66, 0xe8, 0x67, 0x3d, 0x67, 0x93, 0x67, 0xe9, 0x68, 0x3f, 0x68, 0x96, 0x68, 0xec, 0x69, 0x43, 0x69, 0x9a, 0x69, 0xf1, 0x6a, 0x48, 0x6a, 0x9f, 0x6a, 0xf7, 0x6b, 0x4f, 0x6b, 0xa7, 0x6b, 0xff, 0x6c, 0x57, 0x6c, 0xaf, 0x6d, 0x8, 0x6d, 0x60, 0x6d, 0xb9, 0x6e, 0x12, 0x6e, 0x6b, 0x6e, 0xc4, 0x6f, 0x1e, 0x6f, 0x78, 0x6f, 0xd1, 0x70, 0x2b, 0x70, 0x86, 0x70, 0xe0, 0x71, 0x3a, 0x71, 0x95, 0x71, 0xf0, 0x72, 0x4b, 0x72, 0xa6, 0x73, 0x1, 0x73, 0x5d, 0x73, 0xb8, 0x74, 0x14, 0x74, 0x70, 0x74, 0xcc, 0x75, 0x28, 0x75, 0x85, 0x75, 0xe1, 0x76, 0x3e, 0x76, 0x9b, 0x76, 0xf8, 0x77, 0x56, 0x77, 0xb3, 0x78, 0x11, 0x78, 0x6e, 0x78, 0xcc, 0x79, 0x2a, 0x79, 0x89, 0x79, 0xe7, 0x7a, 0x46, 0x7a, 0xa5, 0x7b, 0x4, 0x7b, 0x63, 0x7b, 0xc2, 0x7c, 0x21, 0x7c, 0x81, 0x7c, 0xe1, 0x7d, 0x41, 0x7d, 0xa1, 0x7e, 0x1, 0x7e, 0x62, 0x7e, 0xc2, 0x7f, 0x23, 0x7f, 0x84, 0x7f, 0xe5, 0x80, 0x47, 0x80, 0xa8, 0x81, 0xa, 0x81, 0x6b, 0x81, 0xcd, 0x82, 0x30, 0x82, 0x92, 0x82, 0xf4, 0x83, 0x57, 0x83, 0xba, 0x84, 0x1d, 0x84, 0x80, 0x84, 0xe3, 0x85, 0x47, 0x85, 0xab, 0x86, 0xe, 0x86, 0x72, 0x86, 0xd7, 0x87, 0x3b, 0x87, 0x9f, 0x88, 0x4, 0x88, 0x69, 0x88, 0xce, 0x89, 0x33, 0x89, 0x99, 0x89, 0xfe, 0x8a, 0x64, 0x8a, 0xca, 0x8b, 0x30, 0x8b, 0x96, 0x8b, 0xfc, 0x8c, 0x63, 0x8c, 0xca, 0x8d, 0x31, 0x8d, 0x98, 0x8d, 0xff, 0x8e, 0x66, 0x8e, 0xce, 0x8f, 0x36, 0x8f, 0x9e, 0x90, 0x6, 0x90, 0x6e, 0x90, 0xd6, 0x91, 0x3f, 0x91, 0xa8, 0x92, 0x11, 0x92, 0x7a, 0x92, 0xe3, 0x93, 0x4d, 0x93, 0xb6, 0x94, 0x20, 0x94, 0x8a, 0x94, 0xf4, 0x95, 0x5f, 0x95, 0xc9, 0x96, 0x34, 0x96, 0x9f, 0x97, 0xa, 0x97, 0x75, 0x97, 0xe0, 0x98, 0x4c, 0x98, 0xb8, 0x99, 0x24, 0x99, 0x90, 0x99, 0xfc, 0x9a, 0x68, 0x9a, 0xd5, 0x9b, 0x42, 0x9b, 0xaf, 0x9c, 0x1c, 0x9c, 0x89, 0x9c, 0xf7, 0x9d, 0x64, 0x9d, 0xd2, 0x9e, 0x40, 0x9e, 0xae, 0x9f, 0x1d, 0x9f, 0x8b, 0x9f, 0xfa, 0xa0, 0x69, 0xa0, 0xd8, 0xa1, 0x47, 0xa1, 0xb6, 0xa2, 0x26, 0xa2, 0x96, 0xa3, 0x6, 0xa3, 0x76, 0xa3, 0xe6, 0xa4, 0x56, 0xa4, 0xc7, 0xa5, 0x38, 0xa5, 0xa9, 0xa6, 0x1a, 0xa6, 0x8b, 0xa6, 0xfd, 0xa7, 0x6e, 0xa7, 0xe0, 0xa8, 0x52, 0xa8, 0xc4, 0xa9, 0x37, 0xa9, 0xa9, 0xaa, 0x1c, 0xaa, 0x8f, 0xab, 0x2, 0xab, 0x75, 0xab, 0xe9, 0xac, 0x5c, 0xac, 0xd0, 0xad, 0x44, 0xad, 0xb8, 0xae, 0x2d, 0xae, 0xa1, 0xaf, 0x16, 0xaf, 0x8b, 0xb0, 0x0, 0xb0, 0x75, 0xb0, 0xea, 0xb1, 0x60, 0xb1, 0xd6, 0xb2, 0x4b, 0xb2, 0xc2, 0xb3, 0x38, 0xb3, 0xae, 0xb4, 0x25, 0xb4, 0x9c, 0xb5, 0x13, 0xb5, 0x8a, 0xb6, 0x1, 0xb6, 0x79, 0xb6, 0xf0, 0xb7, 0x68, 0xb7, 0xe0, 0xb8, 0x59, 0xb8, 0xd1, 0xb9, 0x4a, 0xb9, 0xc2, 0xba, 0x3b, 0xba, 0xb5, 0xbb, 0x2e, 0xbb, 0xa7, 0xbc, 0x21, 0xbc, 0x9b, 0xbd, 0x15, 0xbd, 0x8f, 0xbe, 0xa, 0xbe, 0x84, 0xbe, 0xff, 0xbf, 0x7a, 0xbf, 0xf5, 0xc0, 0x70, 0xc0, 0xec, 0xc1, 0x67, 0xc1, 0xe3, 0xc2, 0x5f, 0xc2, 0xdb, 0xc3, 0x58, 0xc3, 0xd4, 0xc4, 0x51, 0xc4, 0xce, 0xc5, 0x4b, 0xc5, 0xc8, 0xc6, 0x46, 0xc6, 0xc3, 0xc7, 0x41, 0xc7, 0xbf, 0xc8, 0x3d, 0xc8, 0xbc, 0xc9, 0x3a, 0xc9, 0xb9, 0xca, 0x38, 0xca, 0xb7, 0xcb, 0x36, 0xcb, 0xb6, 0xcc, 0x35, 0xcc, 0xb5, 0xcd, 0x35, 0xcd, 0xb5, 0xce, 0x36, 0xce, 0xb6, 0xcf, 0x37, 0xcf, 0xb8, 0xd0, 0x39, 0xd0, 0xba, 0xd1, 0x3c, 0xd1, 0xbe, 0xd2, 0x3f, 0xd2, 0xc1, 0xd3, 0x44, 0xd3, 0xc6, 0xd4, 0x49, 0xd4, 0xcb, 0xd5, 0x4e, 0xd5, 0xd1, 0xd6, 0x55, 0xd6, 0xd8, 0xd7, 0x5c, 0xd7, 0xe0, 0xd8, 0x64, 0xd8, 0xe8, 0xd9, 0x6c, 0xd9, 0xf1, 0xda, 0x76, 0xda, 0xfb, 0xdb, 0x80, 0xdc, 0x5, 0xdc, 0x8a, 0xdd, 0x10, 0xdd, 0x96, 0xde, 0x1c, 0xde, 0xa2, 0xdf, 0x29, 0xdf, 0xaf, 0xe0, 0x36, 0xe0, 0xbd, 0xe1, 0x44, 0xe1, 0xcc, 0xe2, 0x53, 0xe2, 0xdb, 0xe3, 0x63, 0xe3, 0xeb, 0xe4, 0x73, 0xe4, 0xfc, 0xe5, 0x84, 0xe6, 0xd, 0xe6, 0x96, 0xe7, 0x1f, 0xe7, 0xa9, 0xe8, 0x32, 0xe8, 0xbc, 0xe9, 0x46, 0xe9, 0xd0, 0xea, 0x5b, 0xea, 0xe5, 0xeb, 0x70, 0xeb, 0xfb, 0xec, 0x86, 0xed, 0x11, 0xed, 0x9c, 0xee, 0x28, 0xee, 0xb4, 0xef, 0x40, 0xef, 0xcc, 0xf0, 0x58, 0xf0, 0xe5, 0xf1, 0x72, 0xf1, 0xff, 0xf2, 0x8c, 0xf3, 0x19, 0xf3, 0xa7, 0xf4, 0x34, 0xf4, 0xc2, 0xf5, 0x50, 0xf5, 0xde, 0xf6, 0x6d, 0xf6, 0xfb, 0xf7, 0x8a, 0xf8, 0x19, 0xf8, 0xa8, 0xf9, 0x38, 0xf9, 0xc7, 0xfa, 0x57, 0xfa, 0xe7, 0xfb, 0x77, 0xfc, 0x7, 0xfc, 0x98, 0xfd, 0x29, 0xfd, 0xba, 0xfe, 0x4b, 0xfe, 0xdc, 0xff, 0x6d, 0xff, 0xff}
